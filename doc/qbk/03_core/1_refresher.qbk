[/
    Copyright (c) 2016-2017 Vinnie Falco (vinnie dot falco at gmail dot com)

    Distributed under the Boost Software License, Version 1.0. (See accompanying
    file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

    Official repository: https://github.com/boostorg/beast
]

[section:asio_refresher Refresher]

To use Beast effectively, a prior understanding of networking is required.
This section reviews networking concepts as a reminder and guide for further
learning.

A
[@https://en.wikipedia.org/wiki/Computer_network ['network]]
allows programs located anywhere to exchange information after opting-in
to communications by establishing a
[@https://en.wikipedia.org/wiki/Data_link ['connection]].
Data is reliably transferred on a connection in either direction
([@https://en.wikipedia.org/wiki/Duplex_(telecommunications) ['full-duplex]])
with bytes arriving in the same order they were sent. These connections, along
with the objects and types used to represent them, are collectively termed
[link beast.concepts.streams ['streams]].

The
[@https://en.wikipedia.org/wiki/Internet ['internet]]
is a global network of interconnected computers which exchange information
using a variety of standardized communication protocols. The most popular
protocol is
[@https://en.wikipedia.org/wiki/Transmission_Control_Protocol ['TCP/IP]],
which this library relies on exclusively. The protocol takes care of the
low level details so that applications see a
['stream], which is the reliable, full-duplex connection carrying the ordered
set of bytes described above.

A vendor supplies a program called a
[@https://en.wikipedia.org/wiki/Device_driver ['device driver]],
enabling networking hardware such as an
[@https://en.wikipedia.org/wiki/Network_interface_controller ['ethernet adaptor]]
to talk to the operating system. This in turn permits running programs to
interact with networking using various flavors of interfaces such as
[@https://en.wikipedia.org/wiki/Berkeley_sockets ['Berkeley sockets]] or
[@https://en.wikipedia.org/wiki/Winsock ['Windows Sockets 2]] ("Winsock").

C++ Networking, represented by __NetTS__ and __Asio__, provides another layer
of abstraction with features such as:

* Deadline timers
* Buffer sequences
* Stream concepts
* Asynchronous I/O

These concepts enable generic programming so that higher levels of abstraction
may be composed to arbitrary degree. In fact, the interfaces and concepts
offered by networking are best described as providing support for general
[@https://en.wikipedia.org/wiki/Input/output ['input/output]] ("I/O")
algorithms, including networking.

[heading Buffers]

A
[@https://en.wikipedia.org/wiki/Data_buffer ['buffer]]
holds a contiguous sequence of bytes used when reading or writing data with
objects that perform I/O.
The networking types __const_buffer__ and __mutable_buffer__ represent
these memory regions as type-safe pointer/size pairs, as shown below:
```
    net::const_buffer cb("Hello, world!", 13);
    assert(string_view(reinterpret_cast<char const*>(cb.data()), cb.size()) == "Hello, world!");

    char storage[13];
    net::mutable_buffer mb(bytes, sizeof(storage));
    std::memcpy(mb.data(), cb.data(), mb.size());
    assert(string_view(reinterpret_cast<char const*>(mb.data()), mb.size()) == "Hello, world!");
```

The concepts
__ConstBufferSequence__ and __MutableBufferSequence__ describe bidirectional
ranges whose value type is convertible to __const_buffer__ and
__mutable_buffer__ respectively. Buffer sequences may be used to transact
in multiple buffers in a single function call, a technique sometimes
referred to as
[@https://en.wikipedia.org/wiki/Vectored_I/O ['scatter/gather I/O]].
Buffer and buffer sequence types are non-owning; creating a copy only results
in a shallow reference and not a duplicate of the underlying memory. These
are all examples of buffer sequences:
```
    net::const_buffer b1;
    net::mutable_buffer b2;
    std::array<net::const_buffer, 3> b3;
```

The __DynamicBuffer__ concept defines a buffer container which may be
resized using a well defined interface. Beast and networking use dynamic
buffers when the amount of storage required to perform an operation is
not known ahead of time, such as when reading a complete HTTP message.

[heading Synchronous I/O]

Synchronous input and output is accomplished through blocking function
calls that provide the complete results of the operation upon returning.
Such operations typically cannot be canceled and do not have a method for
setting a timeout. The __SyncReadStream__ and __SyncWriteStream__ concepts
define requirements for
['synchronous streams],
permitting portable exchange of data using buffer sequence abstractions
to represent bytes and either `error_code` or exceptions to describe any
failures.

A
['synchronous stream algorithm]
is written as a function template accepting a stream object meeting the
named requirements for synchronous reading, writing, or both. This generic
example shows how some text might be written synchronously to a stream,
using exceptions to indicate errors:

```
    template <class SyncWriteStream>
    void hello (SyncWriteStream& stream)
    {
        net::const_buffer buffer("Hello, world!", 13);
        do
        {
            auto bytes_transferred = stream.write_some(buffer); // may throw
            buffer += bytes_transferred; // adjust the pointer and size
        }
        while (buffer.size() > 0);
    }
```

The same function may be written to use error codes instead of exceptions:

```
    template <class SyncWriteStream>
    void hello (SyncWriteStream& stream, error_code& ec)
    {
        net::const_buffer buffer("Hello, world!", 13);
        do
        {
            auto bytes_transferred = stream.write_some(buffer, ec);
            buffer += bytes_transferred; // adjust the pointer and size
        }
        while (buffer.size() > 0 && ! ec);
    }
```

[heading Asynchronous I/O]

An asynchronous operation starts with a call to an
[@boost:/doc/html/boost_asio/reference/asynchronous_operations.html ['initiating function]],
which starts the operation and returns to the caller immediately. This
['outstanding]
asynchronous operation continues to make progress concurrently without
blocking. When the externally observable side effects are fully established,
a movable function object known as a
[@boost:/doc/html/boost_asio/reference/CompletionHandler.html ['completion handler]]
provided in the initiating function call is then queued for execution to
receive the results of the operation, which may include the error code and other
specific information. The operation is considered
['completed]
when the completion handler has been queued for execution with the results.

Every completion handler (also referred to as a
['continuation]
since it represents a continuation of the flow of control that starts
with the initiating function call) has an
[@boost:/doc/html/boost_asio/overview/core/allocation.html ['associated allocator]].
Temporary storage obtained using the associated allocator [*must] be deallocated
before the completion handler is invoked.
Each completion handler also has an
['associated executor].
An executor is a cheaply copyable object that provides an algorithm for
invoking nullary function objects.

Networking prescribes facilities to determine the context
where handlers run. Every I/O object is associated with an
__ExecutionContext__,
which permits implementations to store private per-context data and
also supplies instances of its
__Executor__
that determines where and how a handler is invoked in the
exection context. Instances of __io_context__ offer a basic guarantee:
handlers will only be executed from caller-provided threads which are
currently invoking
[@boost:/doc/html/boost_asio/reference/io_context/run/overload1.html `net::io_context::run`].

An
[@boost:/doc/html/boost_asio/overview/core/strands.html ['associated executor]]
is defined for every completion handler, defaulting to the executor of the
target I/O object. The executor for a completion handler may be customized,
for example by choosing a __strand__.

The __AsyncReadStream__ and __AsyncWriteStream__ concepts define requirements for
['asynchronous streams],
permitting portable exchange of data asynchronously using buffer sequence
abstractions to represent bytes and `error_code` to describe any failures.

An
['asynchronous stream algorithm]
is written as a templated initiating function template which accepts a stream
object meeting the named requirements for asynchronous reading, writing, or
both. The signature for the initiating function includes a
['completion token],
which is a generalization of completion handlers permitting user-defined
types such as futures or coroutines to be substituted as the mechanism by
which the results of the asynchronous operation are delivered. The following
statements all call the same function to asynchronously read data from a
stream, but use a different method for receiving the results:
```
    net::async_read(sock, buffer,
        [error_code ec, std::size_t bytes_transferred]
        {
            if(ec)
                std::cout << "Error: " << ec.message() << "\n";
```

The system
for customizing the return type of initiating functions and obtaining the
actual completion handler from a completion token is known as the
[@http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3747.pdf ['Universal Model for Asynchronous Operations]] (N3747).

This generic example shows the signature for an initiating function to write
some text to a stream:
```
    template <class AsyncWriteStream, class WriteHandler>
    auto async_hello (AsyncWriteStream& stream, WriteHandler&& handler);
```


[/
    [heading Concurrency Without Locking]

    multiple threads calling io_context::run

    When a composed operation submits intermediate completion handlers for operations used to meet its stated effects, the intermediate handlers must use the same executor as that used for the final completion handler
    This is to avoid accessing the underlying I/O object in ways that violate preconditions

    [heading Universal Asynchronous Model]

A strand provides an additional execution
guarantee: function objects submitted to the strand are never executed
concurrently by the underlying executor. Strands permit concurrent asynchronous
applications to be developed which
[@boost:/doc/html/boost_asio/overview/core/strands.html use threads without explicit locking].

    The use of invocable function objects
]


[heading Using Networking]

[warning
    Beast does not manage sockets, make outgoing connections,
    accept incoming connections, handle timeouts, close endpoints,
    do name lookups, deal with TLS certificates, perform authentication,
    or otherwise handle any aspect of connection management. This is
    left to the interfaces already existing on the underlying streams.
]

Library stream algorithms require a __socket__, __ssl_stream__, or other
__Stream__ object that has already established communication with a remote
peer. This example is provided as a reminder of how to work with
sockets:

[snippet_core_2]

Throughout this documentation identifiers with the following names have
special meaning:

[table Global Variables
[[Name][Description]]
[[
    [@boost:/doc/html/boost_asio/reference/io_context.html [*`ioc`]]
][
    A variable of type __io_context__ which is running on one separate thread,
    and upon which an __executor_work_guard__ object has been constructed.
]]
[[
    [@boost:/doc/html/boost_asio/reference/ip__tcp/socket.html [*`sock`]]
][
    A variable of type
    [@boost:/doc/html/boost_asio/reference/ip__tcp/socket.html `tcp::socket`]
    which has already been connected to a remote host.
]]
[[
    [@boost:/doc/html/boost_asio/reference/ssl__stream.html [*`ssl_sock`]]
][
    A variable of type
    [@boost:/doc/html/boost_asio/reference/ssl__stream.html `net::ssl::stream<tcp::socket>`]
    which is already connected and has handshaked with a remote host.
]]
[[
    [link beast.ref.boost__beast__websocket__stream [*`ws`]]
][
    A variable of type
    [link beast.ref.boost__beast__websocket__stream `websocket::stream<tcp::socket>`]
    which is already connected with a remote host.
]]
]

[endsect]
